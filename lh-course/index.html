<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Lectures on Liquid Haskell</title>

    <link href="./css/bootstrap.css" rel="stylesheet">
    <link href="./css/bootstrap-theme.css" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="./css/rust-book.css">
    <link rel="stylesheet" type="text/css" href="./css/editor.css">

  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>

<body class="rustdoc">
 
<div id='toc' class='mobile-hidden'>

</div>

<div id='page'>
<h1 style="border-bottom:none">Lectures on Liquid Haskell</b>
<h2 style="border-bottom:none">Programming with Refinement Types</h2>
<h4 style="border-bottom: 2px solid #ddd"><i>Niki Vazou</i></h4>
<br>

<p><a href="book.pdf">[PDF]</a></p>

<ul class='chapter'>
<li><a href='Lecture_01_RefinementTypes.html'><b>1.</b>Refinement Types</a></li>
<ul class='section'>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.1.</b> Installation</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.2.</b> Basic Refinement Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.3.</b> Subtyping</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.4.</b> From Subtyping to Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.5.</b> Verification Conditions</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.6.</b> Primitive Operations</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.7.</b> Function Types</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.8.</b> Branching and Recursion</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.9.</b> Refined Polymorphism</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.10.</b> Putting it all together: Safe Indexing</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.11.</b> Summary</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.12.</b> Further Reading</a></li>
<li><a href='Lecture_01_RefinementTypes.html#'><b>1.13.</b> Cheatsheet</a></li>
</ul>
<li><a href='Lecture_02_DataTypes.html'><b>2.</b>Data Types</a></li>
<ul class='section'>
<li><a href='Lecture_02_DataTypes.html#'><b>2.1.</b> Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.2.</b> Multiple Measures</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.3.</b> Recursive Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.4.</b> Higher-Order Functions</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.5.</b> Folding (Indexed Lists)</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.6.</b> Data Invariants: Sparse Vectors</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.7.</b> Ordered Lists</a></li>
<li><a href='Lecture_02_DataTypes.html#'><b>2.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_03_Sortedness.html'><b>3.</b>Sortedness &amp; Abstract Refinements</a></li>
<ul class='section'>
<li><a href='Lecture_03_Sortedness.html#'><b>3.1.</b> Ordered Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.2.</b> Abstraction over Sortedness</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.3.</b> Haskell's Lists</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.4.</b> Dependent Pairs</a></li>
<li><a href='Lecture_03_Sortedness.html#'><b>3.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_04_Termination.html'><b>4.</b>Termination</a></li>
<ul class='section'>
<li><a href='Lecture_04_Termination.html#'><b>4.1.</b> Termination Requires Refinements!</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.2.</b> Termination Metrics</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.3.</b> Lexicographic Termination</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.4.</b> The GCD Example</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.5.</b> Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.6.</b> User Defined Data Types</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.7.</b> Mutual Recursion</a></li>
<li><a href='Lecture_04_Termination.html#'><b>4.8.</b> Summary</a></li>
</ul>
<li><a href='Lecture_05_ProofsPrograms.html'><b>5.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_05_ProofsPrograms.html#'><b>5.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_ProofsPrograms.html'><b>6.</b>Programs are Proofs</a></li>
<ul class='section'>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.1.</b> Each Program Proves its type</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.2.</b> Propositions as Refinement Types</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.3.</b> Quantified Theorems</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.4.</b> Theorems about Haskell Functions</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.5.</b> Reusing Proofs, the "because" combinator</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.6.</b> Quantified Proofs</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.7.</b> Monotonicity of the Fibonacci Function</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.8.</b> Generalizing the Monotonicity Proof</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.9.</b> Proofs By Natural Induction</a></li>
<li><a href='Lecture_06_ProofsPrograms.html#'><b>6.10.</b> Summary</a></li>
</ul>
<li><a href='Lecture_06_StructuralInduction.html'><b>7.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_06_StructuralInduction.html#'><b>7.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>7.2.</b> Map Fusion</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>7.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>7.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_06_StructuralInduction.html#'><b>7.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_07_CaseStudyMapReduce.html'><b>8.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.8.</b> Summary</a></li>
<li><a href='Lecture_07_CaseStudyMapReduce.html#'><b>8.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_07_StructuralInduction.html'><b>9.</b>Structural Induction</a></li>
<ul class='section'>
<li><a href='Lecture_07_StructuralInduction.html#'><b>9.1.</b> Structural Induction on Lists</a></li>
<li><a href='Lecture_07_StructuralInduction.html#'><b>9.2.</b> Map Fusion</a></li>
<li><a href='Lecture_07_StructuralInduction.html#'><b>9.3.</b> Monoid Laws for Lists</a></li>
<li><a href='Lecture_07_StructuralInduction.html#'><b>9.4.</b> Using Proved Lemma</a></li>
<li><a href='Lecture_07_StructuralInduction.html#'><b>9.5.</b> Summary</a></li>
</ul>
<li><a href='Lecture_08_CaseStudyMapReduce.html'><b>10.</b>Case Study: Map Reduce</a></li>
<ul class='section'>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.1.</b> Map Reduce Explained</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.2.</b> Map Reduce "Library" Functions:</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.3.</b> Map Reduce "Client" Functions: Summing a List</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.4.</b> Proving Code Equivalence: <code>sum</code> and <code>psum</code></a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.5.</b> Chunk Definition:</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.6.</b> Higher Order Theorem: <code>mRTheorem</code></a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.7.</b> Lemmata for <code>mRTheorem</code> on plus</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.8.</b> Summary</a></li>
<li><a href='Lecture_08_CaseStudyMapReduce.html#'><b>10.9.</b> Appendix: List Manipulation Functions</a></li>
</ul>
<li><a href='Lecture_08_NaturalDeduction.html'><b>11.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.1.</b> Logical Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.2.</b> Native Terms</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.3.</b> Conjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.4.</b> Disjunction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.5.</b> Implication</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.6.</b> Negation</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.7.</b> Forall</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.8.</b> Exists</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.9.</b> Example 1: existsAll</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.10.</b> Example 2: Distributing Qualifiers</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.11.</b> Example 3: List Properties</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.12.</b> Example 4: Natural Induction</a></li>
<li><a href='Lecture_08_NaturalDeduction.html#'><b>11.13.</b> Summary</a></li>
</ul>
<li><a href='Lecture_09_DataPropositions.html'><b>12.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.1.</b> Even Numbers</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.2.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.3.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.4.</b> Typing of Expressions</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.5.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.6.</b> Summary</a></li>
<li><a href='Lecture_09_DataPropositions.html#'><b>12.7.</b> Appendix: Missing Code</a></li>
</ul>
<li><a href='Lecture_09_NaturalDeduction.html'><b>13.</b>Natural Deduction</a></li>
<ul class='section'>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.1.</b> Logical Properties</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.2.</b> Native Terms</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.3.</b> Conjunction</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.4.</b> Disjunction</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.5.</b> Implication</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.6.</b> Negation</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.7.</b> Forall</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.8.</b> Exists</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.9.</b> Example 1: existsAll</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.10.</b> Example 2: Distributing Qualifiers</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.11.</b> Example 3: List Properties</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.12.</b> Example 4: Natural Induction</a></li>
<li><a href='Lecture_09_NaturalDeduction.html#'><b>13.13.</b> Summary</a></li>
</ul>
<li><a href='Lecture_10_DataPropositions.html'><b>14.</b>Data Propositions</a></li>
<ul class='section'>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.1.</b> Even Numbers</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.2.</b> Metatheory of Programming Languages</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.3.</b> Evaluation of Expressions</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.4.</b> Typing of Expressions</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.5.</b> Soundness = Progress + Preservation</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.6.</b> Summary</a></li>
<li><a href='Lecture_10_DataPropositions.html#'><b>14.7.</b> Appendix: Missing Code</a></li>
</ul>
<li><a href='Task1.html'><b>15.</b>Task 1: Program Verification</a></li>
<ul class='section'>
<li><a href='Task1.html#'><b>15.1.</b> 1. Lists</a></li>
<li><a href='Task1.html#'><b>15.2.</b> 2. Insertion Sort</a></li>
<li><a href='Task1.html#'><b>15.3.</b> 3. Merge Sort</a></li>
</ul>
<li><a href='Task1All.html'><b>16.</b>Task 1: Program Verification</a></li>
<ul class='section'>
</ul>
<li><a href='Task2.html'><b>17.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2.html#'><b>17.1.</b> 1. Fusions</a></li>
<li><a href='Task2.html#'><b>17.2.</b> 2. Higher Order Properties</a></li>
<li><a href='Task2.html#'><b>17.3.</b> 3. Encoding of Logical Properties</a></li>
</ul>
<li><a href='Task2All.html'><b>18.</b>Task 2: Proving Theorems</a></li>
<ul class='section'>
<li><a href='Task2All.html#'><b>18.1.</b> 1. Fusions</a></li>
</ul>
</ul>


</div>
</body>
</html>
